import path from 'path'
import { nanoid } from 'nanoid'
const createContent = async (_, {data, newEventData = {}}, {prisma, tokenData, space} ) => {
    if(!tokenData){
        throw new Error('Unauthorized action!')
    }

    const {
        file,
        title,
        description = '',
        postedFromEop = false,
        coordinates
    } = data
    let mediaUrl = ''
    let {eventId} = data
    const {createReadStream, filename, mimetype} = await file
    const [mediaType, fileExt] = mimetype.split('/')
    const authorId = tokenData.id

    console.log('mimetype: ', mimetype)

    // Check if authorId is valid.
    const prismaAuthor = await prisma.user.findFirst({
        where: {id: authorId}
    })
    if(!prismaAuthor){
        throw new Error('Invalid user.')
    }
    
    // Check if eventId is valid, if is provided for connection.
    if(eventId){
        const prismaEvent = await prisma.event.findFirst({
            where: {id: eventId}
        })
        if(!prismaEvent){
            throw new Error('Invalid event.')
        }
    } else {
        eventId = ''
    }

    // Check coordinates.
    if(!coordinates){
        throw new Error('Location has not been provided.')
    }

    // Upload file.
    if(mediaType === 'image'){
        mediaUrl = await new Promise((resolve) => {
            space.upload({
                Body: createReadStream(filename),
                Bucket: process.env.SPACES_PHOTO_BUCKET,
                Key: path.basename(`${nanoid()}.${fileExt}`),
                ACL: 'public-read'
            }, (err, data) => {
                if (err) {
                    throw new Error('Unable to upload file.')
                } else if (data) {
                    resolve(data.Location)
                }
            })
        })
    } else {
        // Need to add video handling.
        console.log('Only images are handled right now.')
        throw new Error('That file type is not supported.')
    }

    // Create content and connects it to existing event or creates new one.
    // If new event is created, connects event to organizer(User)
    return await prisma.content.create({
        data: {
            mediaType, // Get this from 'file'
            mediaUrl: mediaUrl,
            mediaPreviewUrl: mediaUrl, // This should be generated by another service.
            title,
            postedFromEop,
            author: {
                connect: {
                    id: authorId
                }
            },
            description: description,
            event: {
                connectOrCreate: {
                    where: { id: eventId },
                    create: {
                        title: newEventData.title ? newEventData.title : 'Unnamed Event',
                        coordinates,
                        description: newEventData.description ? newEventData.description : '',
                        country: newEventData.country ? newEventData.country : '',
                        city: newEventData.city ? newEventData.city : '',
                        state: newEventData.state ? newEventData.state : '',
                        landmark: newEventData.landmark ? newEventData.landmark : '',
                        organizer: {
                            connect: {
                                id: authorId
                            }
                        }
                    }
                }
            }
        },
        include: {
            event: true
        }
    })
}

export default createContent