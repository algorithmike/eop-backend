import path from 'path'
import { nanoid } from 'nanoid'

import getLocFromCoords from '../../utils/locationDetails'


const createContent = async (_, {data, newEventData = {}}, {prisma, tokenData, space} ) => {
    if(!tokenData){
        throw new Error('Unauthorized action!')
    }

    const {
        file,
        title,
        description = '',
        postedFromEop = false,
        coordinates
    } = data
    let mediaUrl = ''
    let {eventId} = data
    const {createReadStream, filename, mimetype} = await file
    const authorId = tokenData.id
    const [mediaType, fileExt] = mimetype.split('/').map(item => item.toLowerCase())
    let properBucket;


    // Create automatic values of event location based on coordinates.
    let [, latitude, , longitude] = coordinates.split(' ')
        .map(item => item.trim().replace(/,/g, ''))
    
    console.log("location: ", location);
    const location = await getLocFromCoords(latitude, longitude)
    console.log("longitude: ", longitude);
    console.log("latitude: ", latitude);


    if(mediaType === 'image'){
        properBucket = process.env.SPACES_PHOTO_BUCKET
        // Need to generate image preview image.
    } else if(mediaType === 'video'){
        properBucket = process.env.SPACES_VIDEO_BUCKET
        // Need to generate video preview image.
    } else {
        throw new Error('That file type is not supported.')
    }

    // Check if authorId is valid.
    const prismaAuthor = await prisma.user.findFirst({
        where: {id: authorId}
    })
    if(!prismaAuthor){
        throw new Error('Invalid user.')
    }
    
    // Check if eventId is valid, if is provided for connection.
    if(eventId){
        
        const prismaEvent = await prisma.event.findFirst({
            where: {id: eventId}
        })
        if(!prismaEvent && eventId === 'new'){
            throw new Error('Invalid event.')
        }
    } else {
        eventId = ''
    }

    // Check coordinates.
    if(!coordinates){
        throw new Error('Location has not been provided.')
    }

    // Upload file.
    mediaUrl = await new Promise((resolve) => {
        space.upload({
            Body: createReadStream(filename),
            Bucket: properBucket,
            ContentType: mimetype,
            Key: path.basename(`${nanoid()}.${fileExt}`),
            ACL: 'public-read'
        }, (err, data) => {
            if (err) {
                throw new Error('Unable to upload file.')
            } else if (data) {
                resolve(data.Location)
            }
        })
    })

    // Create content and connects it to existing event or creates new one.
    // If new event is created, connects event to organizer(User)
    return await prisma.content.create({
        data: {
            mediaType, // Get this from 'file'
            mediaUrl: mediaUrl,
            mediaPreviewUrl: mediaUrl, // This should be generated by another service.
            title,
            postedFromEop,
            author: {
                connect: {
                    id: authorId
                }
            },
            description: description,
            event: {
                connectOrCreate: {
                    where: { id: eventId },
                    create: {
                        title: newEventData.title ? newEventData.title : 'Unnamed Event',
                        coordinates,
                        description: newEventData.description ? newEventData.description : '',
                        country: location.country,
                        city: location.city,
                        state: location.state,
                        landmark: location.landmark ? location.landmark : location.streetAddress,
                        organizer: {
                            connect: {
                                id: authorId
                            }
                        }
                    }
                }
            }
        },
        include: {
            event: true
        }
    })
}

export default createContent